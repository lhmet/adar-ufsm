---
title: "Entrada e saída de dados"
author: "Jônatan Tatsch"
date: "`r format(Sys.Date(), format = '%d-%m-%Y')`"
output:
  html_document:
    #code_folding: show
    fig_caption: yes
    fig_width: 6
    highlight: kate
    keep_md: yes
    number_sections: yes
    toc: yes
    #toc_float: yes
---

```{r Chunk0, comment="",prompt=FALSE, echo=FALSE, eval=TRUE, error=TRUE,highlight=TRUE,message=FALSE,warning=FALSE, results='hide'}
rm(list=ls())
# definindo globalmente tz = "GMT"
#Sys.setenv(TZ = 'GMT')
# data manipulation packages
pcks <- c("knitr", "knitcitations", "pander", "htmlTable")
invisible(sapply(pcks, require, character.only = TRUE, quietly = TRUE))
# configuraçoes knitr
opts_chunk$set(cache = FALSE, fig.path = "figs/")
```

- - -

![](figs/adar.png)

- - -

# Introdução 

O R permite ler dados de uma variedade de fontes e formatos. Nesta unidade veremos como importar dados de arquivos texto, binários e de outros softwares para o R. Para uma descrição mais abrangente sobre importação e exportação de dados no R consulte a documentação de cada função e o manual [R Data Import/Export](http://cran.r-project.org/doc/manuals/r-release/R-data.html).

# Amostras pequenas de dados

## Entrada dados pela linha de comando

Até agora nós trabalhamos com dados que criados a partir de comandos diretamente digitados no console do R. Para criação de vetores usamos a função `c` que combina valores em um vetor. 

```{r Chunk10, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# Exemplo: vetor
v1 <- c(1,3,4:8,10)
v1
```

### scan()

Nós podemos informar os números de um vetor a partir do teclado, um de cada vez usando e quando terminar teclar enter:

```{r Chunk1110, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=FALSE}
# Exemplo: vetor
v2 <- scan()
# digite os números do v1, ao terminar, tecle enter
```

A função `scan()` também pode ler dados de arquivos, mas a sua saída é um vetor, ou seja ela não mantém a  estrutura dos dados contidos no arquivo.

```{r Chunk1111, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# Exemplo: vetor
vetor_aq <- scan("data/airquality.txt")
# parte inicial dos dados
head(vetor_aq, 100)
# parte final
tail(vetor_aq, 100)
# dados são importados como vetor
is.vector(vetor_aq)
mode(vetor_aq)
```

Vimos que `Data-frames` são geralmente criados pela função `data.frame`, conforme o exemplo abaixo.

```{r Chunk1112, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# Exemplo: data-frame 
dados <- data.frame(dates = c("2013-01-01", "2013-01-01", "2013-01-01"),
                    cidade = c("Santa Maria", "Sao Sepe", "Caçapava"), 
                    temperatura = c(31, 35, 21),
                    chuva = c(3, 10, 14))
dados                    
```

### readline()

Para ler apenas uma linha de dados a partir do teclado como `character` usamos a função **`readline()`**:

```{r Chunk1120, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
sentenca <- readline(prompt = "digite alguma coisa e tecle enter para continuar: ")
sentenca
```

Essa função pode ser utilizado como uma forma de controlar um *looping*. Esse exemplo ilustra o uso da função `lapply()` para execução de laços ou *loopings* ao longo de um vetor de índices. Essa função será vista futuramente no curso.

```{r Chunk1121, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=FALSE}
# para reprodutibilidade
set.seed(123)
# looping ao longo da sequência de 1 a 5
l <- sapply(1:5, 
         function(i){
           # cria vetor com números aleatórios com distribuição uniforme
           x <- runif(n = 100, min = 1,max = 50)
             # anomalia acumulada
             y <- cumsum(x - mean(x))
              plot(y, type = "o")
              abline(h = 0, lty = 2)
               # leitura de linha, só após teclar enter vai gerar próximo gráfico
               readline(prompt = "tecle <enter> para continuar: ")
         }
       )
l
```

### Impressão na tela

No modo interativo do R podemos imprimir os valores de um objeto na tela digitando o nome do objeto.

```{r Chunk1130, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
x <- 1:3
y <- x^2
y
# ou 
print(x^2)
```

Entretanto isso não é possível quando precisamos mostrar o valor de uma variável dentro do corpo de uma função ou dentro de um laço (*looping*). Nesse caso podemos usar a função `print()`:

```{r Chunk1131, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# dentro de uma função 
# digitando o nome do objeto não imprimi na tela
fcubo <- function(x) {
         classe <- class(x)
         # intenção de mostrar objeto de entrada
         classe
         x^3
        }
fcubo(2)
# adicionando print 
cubo <- function(x) {
         # mostra objeto de entrada
         classe <- class(x)
         print(classe)
         x^3
        }
fcubo(-3) # não imprime classe do objeto de entrada
cubo(-3)  # imprime classe do objeto de entrada
```

#### `cat()` ao invés de `print()`

É melhor usar a função `cat()` ao invés da função `print()`, já que a `print()` permite a impressão de apenas um único objeto enquanto a `cat()` não. Compare os resultados das duas funções:

```{r Chunk1132, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
print("abc")
cat("abc\n") # \n indica quebra de linha
x
cat("os elementos de x são: ", x, "\n")
cat("os elementos de x são: ", x, sep = "")
cat("os elementos de x são: ", x, sep = "\n")
k <- c(5, 12, 13, 8, 88)
cat(k, sep = c(".","___"," ---> ","\n","\n"))
```

## textConnection()

Imagine que você tivesse recebido essa amostra de dados por e-mail:
   
    dates      cidade temperatura chuva
    2013-01-01 SM          13     3
    2013-01-01 SS          30    10
    2013-01-01 CV          22    12

Para converter essa pequena amostra de dados em um *data frame* nós podemos selecionar, copiar e colar o texto no primeiro argumento da função `textConnection`, e então usar a função `read.table`. 

```{r Chunk120, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
texto <- "       dates      cidade temperatura chuva
    2013-01-01 SM          31     3
    2013-01-01 SS          35    10
    2013-01-01 CV          21    14"
# conexão de texto
tc <- textConnection(object = texto)
tc
x <- read.table(file = tc, header = TRUE)
x
```

# Exportando e recuperando objetos do R no formato textual

## `dput()`, `dget`, `dump` e `source`.

Uma função útil para passar os dados a alguém que precisa reproduzi-los é a função `dput()` (que pode ser traduzido como "despejar"). Ela escreve uma representação textual de um objeto R que pode ser escrita em um arquivo. Para recriar o objeto basta usar a função `dget()`.

```{r Chunk210, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
x
# representação textual do objeto x
dput(x)
# salva representação textual de x em um arquivo
dput(x, file = "data/x.txt")
# recuperando x a partir do arquivo
y <- dget("data/x.txt")
# alterar valores de y
y <- y[, 3:4] - sqrt(2)
y
# verificar existência de x e y 
ls()
# listando variáveis que começam com x ou y
ls(pattern = "^[xy]")
# salvando mais de um objeto em um arquivo
dump(ls(pattern = "^[xy]"), file = "R/xy.R")
# vamos apagar x e y do espaco de trabalho
rm(x, y)
# x e y não existem mais
ls()
# recuperando os objetos x e y salvos em xy.R
source("R/xy.R")
ls()
x
y
```

Portanto diferente da escrita dos dados em si para um arquivo texto as funções `dump()` e `dput()` armazenam os **dados** e os **metadados**, assim outro usuário não precisa especificá-los novamente. Assim o usuário que recebe a saída do `dput()` em um arquivo, pode recriar os dados pelo comando `dget("nomedoarquivo")`. 

```{r Chunk211, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# representação textual de um data.frame
x2 <- structure(list(dates = c("2013-01-01", "2013-01-01", "2013-01-01"), 
                     cidade = c("SM", "SS", "CV"), 
                     temperatura = c(31L, 35L, 21L), 
                     chuva = c(3L, 10L, 14L)), 
                     .Names = c("dates", "cidade", "temperatura", "chuva"), 
                class = "data.frame", 
                row.names = c(NA, -3L)
                )
x2
```

**Vantagens:**

- armazena os **dados e os metadados**
- rápida e fácil recuperação dos dados

**Desvantagens:**

- armazenamento de dados nesse formato não é muito eficiente em termos de espaço em disco
- pouca legibilidade dos dados 

Esse procedimento é geralmente recomendado para fornecer pequenas amostras de dados (e-mails por exemplo)

# Dados de pacotes do R

O `R` possui diversos conjuntos de dados internos que são automaticamente carregados quando iniciado. Esses dados são usados nos exemplos do `help()` de diversas funções para ilustrar o uso e a aplicação delas. Esses dados podem ser carregados com a função `data`.

```{r Chunk300, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
data()
# Annual Precipitation in US Cities, p/ mais informações "?precip"
data(precip)
# primeiros 30 elementos dos dados precip
head(precip, n = 30)
# New York Air Quality Measurements, , p/ mais informações "?airquality"
data(airquality)
# primeiras linhas dos dados
head(airquality, n = 10)
```

# Arquivos texto

Dados armazenados em um arquivo texto (do tipo [ASCII](http://pt.wikipedia.org/wiki/ASCII])) podem ser facilmente importados no R.

O formato mais comum de armazenar uma tabela de dados num arquivo texto é com os registros ao longo das linhas e as variáveis ao longo das colunas. Os valores de cada coluna de uma linha são separados por um caractere separador: vírgula (`,`), espaço (`,`), tab (`\t`) e etc.

**A função mais importante para leitura de dados de um arquivo texto é a `read.table()` que  armazena os dados no formato de uma data-frame**. Essa função possui diversos parâmetros para ajustar a importação de acordo com as peculiaridades do formato de dados do arquivo. O valor *default* do parâmetro `sep` é um ou mais caracteres de `espaço` e `tabs`. Devido as diversas opções de separadores existem outras funções essencialmente iguais a `read.table()` com a diferença no separador, por exemplo as funções: `read.csv(), read.csv2(), read.delim()` usam como o argumento separador `,`, `;` e `\t` . Para detalhes sobre essas funções o *help* de cada uma. Uma vez que essas funções aceitam qualquer argumento da `read.table()` elas são mais convenientes que usar a `read.table()` e configurar os argumentos apropriados manualmente.

Alguns argumentos da função `read.table()` são:

* `file` nome do arquivo
* `header` lógico (TRUE ou FALSE) indicando se o arquivo tem ou não linha de cabeçalho
* `sep` um caractere indicando como as colunas são separadas
* `colClasses`, um vetor caractere indicando as classes de cada coluna no conjunto de dados
* `nrows`, número de linhas no conjunto de dados
* `comment.char`, um caractere indicando o caractere usado como comentário (para ignorar essas linhas)
* `skip`, o número de linhas que devem ser "puladas" desde o início do arquivo
* `stringsAsFactors`, lógico, as variáveis do tipo `character` devem ser codificadas como `factor`?

Esse último argumento pode ser definido também através da configuração global de opções no R pelo comando: `options(stringsAsFactors=F)`.

Quando se faz a leitura de dados com `read.table("nome_do_arquivo")` o R automaticamente: 

+ pula linhas que começam com '#'
+ descobre quantas linhas tem o arquivo e quanta memória precisa ser alocada
+ descobre qual o tipo de variável em cada coluna

Para arquivos de tamanho moderado a pequeno essa forma de especificar os argumentos funciona satisfatoriamente. Vamos ver alguns exemplos de leitura de dados hidrometeorológicos no formato texto amplamente usados em aplicações da Meteorologia.

## Arquivos textos de bases de dados hidrometeorológicos brasileiras

### [hidroweb-ANA](http://hidroweb.ana.gov.br/)

```{r Chunk410, message=FALSE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
# definindo interpretação de caracteres: caracteres não devem ser tratados como fatores
options(stringsAsFactors = F)
# leitura de dados pluviométricos diários da ANA
dprec <- read.csv2(file = "data/CHUVAS.TXT", 
                   skip = 15, 
                   head = T, 
                   fill = T)
# primeiras linhas
head(dprec)
# últimas linhas
tail(dprec)
 # corrigindo nome da primeira coluna
 names(dprec)[1] <- "EstacaoCodigo"
 # removendo última coluna que só tem NAs
 dprec <- dprec[ , -ncol(dprec)]
  # estrutura dos dados
  str(dprec)
# Fazendo a mesma leitura com read.table
dprec2 <- read.table(file = "data/CHUVAS.TXT", 
                   skip = 15, 
                   head = T, 
                   stringsAsFactors = F,
                   fill = T,
                   sep = ";",
                   dec = ",")
head(dprec2)
```

### [BDMEP-INMET](http://www.inmet.gov.br/portal/index.php?r=bdmep/bdmep)

```{r Chunk411, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
x <- read.csv2(file = "data/83004.txt", 
               header = F, 
               skip = 16,
               stringsAsFactors = F,
               na.strings = ""
               )
head(x)
str(x)
```

Os dados lidos não incluíram a linha de cabeçalho com os nomes das variáveis. Nós pulamos essa linha porque o nome das variáveis está de acordo como número de colunas do arquivo. Então se tentarmos ler um arquivo de dados que contém linhas com número de registros diferentes ocorrerá um erro pois os dados não são tabulares. 

Outro aspecto nos dados lidos é que aparecem vários `<NA>`, que é o símbolo para dados do tipo `character` faltantes. A razão dos terem sido interpretados dessa forma deve-se a um caractere (`</pre>`) encontrado na última linha do arquivo. Digite na linha de um terminal linux o comando:

    tail data/83004.txt 
    
para imprimir na tela apenas a parte final do arquivo. 
Para que os dados numéricos não sejam interpretados como caractere nós poderíamos executar a função `read.table(..., nrows = 5878)`, que ignoraria a última linha do arquivo e os dados seriam interpretados como `numeric`.

```{r Chunk412, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
x1 <- read.csv2(file="data/83004.txt", 
               header = F, 
               skip = 16,
               stringsAsFactors = F,
               dec = ".",
               na.strings = "",
               nrows = 5878              
)
head(x1)
str(x1)
```

Outra alternativa seria converter as colunas de interesse (todas exceto as de 1 a 3) para `numeric` através da função `as.numeric()` usando a função `apply` ao longo das colunas:

```{r Chunk413, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# corrigindo classe dos dados
# convertendo de character para numeric
x[, -c(1:3)] <- apply(x[,-c(1:3)], 2, as.numeric)
str(x)
# razão dos avisos
as.numeric("NA")
```

Mas e o nome das variáveis?

Nós ignoramos a linha de cabeçalho por que nos dados do INMET ocorre uma variável denominada `VelocidadeVentoInsolacao`. Essa *string* deveria ser separada em duas.

```{r Chunk414, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# lendo somente o nome das variaveis
vnames <- read.csv2(file="data/83004.txt", 
                    header = F, 
                    skip = 15,
                    stringsAsFactors = F,
                    dec = ".",
                    na.strings = "",
                    nrows = 1)
vnames
# convertendo de data frame para vetor
vnames <- c(t(vnames))
# número de variáveis é diferente do número de colunas do arquivo
length(vnames) == ncol(x)
# corrigindo nomes das variaveis
#   substitui "VelocidadeVentoInsolacao" por "VelocidadeVento"
vnames[13] <- "VelocidadeVento"
# acresenta na 14a posição dos nomes a variável "insolacao" e
# desloca os elementos orginais do vetor 
vnames <- c(vnames[1:13], "insolacao", vnames[14:length(vnames)])
length(vnames)
ncol(x)
names(x) <- vnames
head(x)
```

Finalmente vamos escrever os dados do INMET corretamente organizados.

```{r Chunk415, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
write.csv2(x,
           file = "data/83004_clean.txt", 
           na = "-9999",
           row.names = F)
```


## Arquivos texto com linhas e colunas em branco

Vamos importar o arquivo texto `airquality.txt` que possui algumas linhas e colunas faltantes.


```{r Chunk420, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE, error=TRUE}
# leitura do arquivo airquality.txt
aq0 <- read.table(file = "data/airquality.txt", 
                  na.strings = "-99.9", 
                  head = F)
```

A função `count.fields()` permite contar o número de registros em cada linha. Assim encontramos as linhas com número de registros fora do padrão.

```{r Chunk421, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# conta o num. de registros por linha
cf <- count.fields(file = "data/airquality.txt", sep = " ")
cf
# contando ocorrências de registros
table(cf)
# linhas com 5 registros
qlinha <- which(cf == 5)
qlinha
# Contornando a falta de registros com o argumento fill = T
# que preenche colunas faltantes com NA
aq <- read.table(file = "data/airquality.txt", 
                 na.strings = "-99.9", 
                 head = F, 
                 fill = T)
names(aq) <-  c("Ozone",  "Solar.R", "Wind", "Temp", "Month", "Day")
# primeiras linhas do dados
head(aq)
# resumo da estrutura dos dados
str(aq)
# resumo estatístico dos dados
summary(aq)
# Solar.R == -999 ?
# Radiação solar negativa é fisicamente impossível
# provável erro de digitação para  o label de dado faltante
aq <- read.table(file = "data/airquality.txt", 
                 na.strings =c("-99.9","-999"), 
                 head = F, 
                 fill = T)
names(aq) <- c("Ozone", "Solar.R", "Wind", "Temp", "Month", "Day")
summary(aq)
# salvando arquivo com correções em arquivo separado por tab
write.table(x = aq, 
            file = "data/aq.txt", 
            sep = "\t", 
            na = "-999", 
            dec = ".", 
            row.names = F)
# mostra arquivo
file.show("data/aq.txt")
```

Fazendo alterações manuais nos dados `aq` via R:

```{r Chunk422, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=FALSE}
# editar dados
aq_new <- fix(aq)
```

## Arquivos formatados com largura fixa

Alguns arquivos texto com dados tabulares podem não conter separadores (para p.ex. economizar espaço de disco). Outros arquivos podem ser formatados usando largura fixa para reservar o espaço de cada variável, o que facilita a legibilidade dos dados. Nesses casos usamos a função `read.fwf()`. Vamos usar como exemplo o arquivo de dados do Índice de Oscilação Sul (SOI) obtido no site do [National Weather Service - Climate Prediction Center (NWS-CPC)](http://www.cpc.ncep.noaa.gov).

```{r Chunk440, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# link para os dados do SOI
link <- "http://www.cpc.ncep.noaa.gov/data/indices/soi"
```

Abrindo o link dos dados no navegador para visualização do formato.

```{r Chunk441, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=FALSE}
browseURL(url = link)
```

Leitura dos dados: 

```{r Chunk442, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
#soi <- read.fwf(file = link,                           # nome do arquivo ou link
soi <- read.fwf(file = "data/SOI.txt",                       # sem internet, usar esse arquivo
                skip = 4,                               # pula 4 linhas
                header = F,                             # sem cabeçalho
                nrows = 70,                             # num. de linhas
                widths = c(4, rep(6,12)),                # largura dos campos das variáveis
                na.strings = "-999.9",                  # string para dados faltantes
                col.names = scan("data/SOI.txt",             # varredura do arquivo
                #col.names = scan(link,             # varredura do arquivo
                                 what = "character",    # tipo dos dados a serem lidos
                                 skip = 3,              # pula 3 linhas
                                 nmax = 13)             # num. max de registros a serem lidos
                )
```

Vamos alterar a estrutura dos dados: ao invés dos dados serem distribuídos ao longo das colunas, vamos estruturá-los como série temporal, ou seja cada valor mensal corresponderá a uma linha. 

```{r Chunk443, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# converte a matriz de dados para um vetor (em sequencia cronológica)
soi_v <- c(t(soi[, -1]))
# criando um data frame com valores de SOI, mes e ano
soi_df <- data.frame(ano = rep(soi$YEAR, each = 12),
                     mes = rep(1:12, length(soi[,1])),
                     soi = soi_v)
# escrevendo dados SOI em um arquivo CSV
write.csv(x = soi_df, 
          file = "data/SOI.csv", 
          na = "-999.9", 
          row.names = F)
```

Vamos ler os dados reestruturados que foram salvos no formato [csv](http://en.wikipedia.org/wiki/Comma-separated_values) usando uma função que permite a escolha do arquivo de forma iterativa.

```{r Chunk444, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=FALSE}
# leitura de dados com escolha interativa do arquivo
soi.df <- read.csv(file = file.choose(),
                   # file.choose só é válido em sistema *unix
                   # no windows é choose.file()
                   header = T,
                   na.strings = "-999.9")
```

Clique duas vezes sobre o arquivo `SOI.csv`.

```{r Chunk445, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=FALSE, eval=TRUE}
soi.df <- read.csv(file = "data/SOI.csv",
                   header = T,
                   na.strings = "-999.9")
```

```{r chunk446, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
head(soi.df)
str(soi.df)
```

A função `read.fortran()` é uma função similar à `read.fwf()` e permite usar especificações de colunas no estilo [Fortran](http://en.wikipedia.org/wiki/Fortran).

## Arquivos texto não estruturados

Em alguns casos é necessário ler arquivos textos sem uma estrutura definida como no caso de arquivos delimitados. Se o arquivo não é bem estruturado é mais fácil ler cada linha de texto separadamente e depois decompor e manipular o conteúdo do texto. 
A função `readLines()` é adequada para isso. Cada linha é tratada como um elemento de um vetor do tipo `character`.

Vamos importar os dados do INMET, mas dessa vez vamos focar no cabeçalho, onde estão as informações da estação meteorológica.

```{r Chunk450, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# leitura do cabecalho do arquivo de dados de uma estação do inmet
cab <- readLines("data/83004.txt")
head(cab)
# somente linhas com coordenadas da estação
cab[5:7]
is.vector(cab[5:7])
# arranjando em coluna
cbind(cab[5:7])
# selecionando somente os dados e o nome das variáveis
cab[-c(1:15)][1:10]
# escrevendo dados com writeLines
writeLines(text = cab[-c(1:15)] , con = "data/83004_limpo.txt")
# visualizando dados gerados sem cabeçalho usando função system
# (específico para sistema *unix)
system("head -11 data/83004_limpo.txt", intern = TRUE)
```

A função `writeLines()` escreve os elementos do vetor de caracteres um de cada vez em um arquivo texto.

## Arquivos texto grandes

Mas quando os dados são grandes a definição desses argumentos na chamada da função fazem o R rodar de forma mais rápida e eficiente.
Quando trabalha-se com dados enormes algumas coisas importantes são: 

- ler o *help* da `read.table()`, que contém diversas dicas

- fazer um cálculo aproximado da memória requerida para armazenar seus dados, se os dados são maiores que a memória de sua máquina você já pode parar aqui.

- defina o argumento `comment.char = ""` se não há linhas comentadas em seu arquivo de dados.

- Use o argumento `colClasses`. Especificando as classes das variáveis torna o R até 2 vezes mais rápido na leitura.

- defina o número de linhas no arquivo texto. No linux você pode usar o comando `wc -l arquivo` para determinar o seu número de linhas.

Quando se trabalha com dados enormes as informações sobre seu sistema operacional são fundamentais:

+ quantidade de memória disponível e aplicações em uso

         $ htop

+ usuários logados no mesmo sistema

         $ last

+ sistema operacional (SO), 32 ou 64 bit?

```{r , comment=""}
data.frame(Sys.info())
```


É possível estimar a memória necessária para leitura de dados. Suponha um conjunto de dados de 1500000 linhas e 120 colunas, todas colunas são da classe `numeric`. Aproximadamente quanta memória é necessária para armazená-lo em um *data frame*? Vamos assumir que os dados sejam numéricos não inteiros (8 bytes/registro).

+ 1500000 x 120 x 8 bytes/registro = 1440000000 bytes = 1440000000/(2^20^) bytes/MB = 1373.29 MB = 1,34 GB


```{r Chunk430, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# cálculo de memória
bytes_per_reg <- 8
nlins <- 1500000
ncols <- 120
res <- nlins * ncols * bytes_per_reg
res/(2^20) # bytes/MB
res/(2^20)/1000 # GB
```

Para mais informações sobre a função `read.table()` consulte o help da função `?read.table`.

Se seus dados estão disponíveis em uma planilha do Excel ou similar, você pode exportá-lo para o formato [csv](http://en.wikipedia.org/wiki/Comma-separated_values) (*comma separated value*) via `<salvar como>`. 
Se você possui uma grande quantidade de arquivos no formato Excel, considere o post [Read Excel files from R](http://www.r-bloggers.com/read-excel-files-from-r/) do [Rbloogers](http://www.r-bloggers.com) para referência.


# Arquivos de dados binários 

Vários softwares armazenam dados no formato binário. Os arquivos no formato binário são frequentemente menores que os de formato texto. Em contrapartida, a legibilidade humana dos dados é menor em comparação ao formato texto ASCII.

## Salvando e carregando dados do R

Em situações que os dados brutos exigem um processamento de dados significativo salvar os dados em formato binário próprio do R torna-se uma alternativa prática para análise posterior dos dados. 

### Salvando e carregando objetos em arquivos `.RData`

Para mostrar como usar as funções `save()` e `load()` vamos utilizar os dados pluviométricos lidos anteriormente e selecionar as colunas de interesse. Depois disso o objeto `chuva_df` será armazenado em arquivo binário do R com a extensão `.RData`.

```{r Chunk6110, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# primeiras linhas
head(dprec[, 1:10])
# selecionando somente dados diarios do dia 1 a 31 de cada ano
chuva_df <- dprec[, c(3, 14:44)]
# arquivo binario do R
save(chuva_df, file = "data/chuva_df.RData")
# verificando se arquivo foi salvo no diretório
file.exists("data/chuva_df.RData")
```

Como o objeto `chuva_df` foi salvo em um arquivo, vamos removê-lo e então recuperá-lo carregando os dados armazenado no arquivo `chuva_df.RData`.

```{r Chunk6111, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE, error=TRUE}
# apagando chuva_df do ambiente de trabalho
rm(chuva_df)
# verifica existência de objeto
exists(chuva_df)
# carregando chuva_df
load(file = "data/chuva_df.RData")
ls()
# para carregar os dados e saber o nome com que foram salvos
print(load(file = "data/chuva_df.RData"))
head(chuva_df[, 1:10])
```

Um **vantagem desse formato** é que os objetos criados podem ser lidos pelo R independente do sistema operacional e da arquitetura do computador, tornando muito prático o acesso aos dados. 
Cada vez que uma sessão do R é finalizada, uma janela surge perguntando se deseja salvar o espaço de trabalho (`save the workspace image`), que nada mais é do que um arquivo binário chamado `.RData` no diretório de trabalho. Assim quando iniciar a sessão se o arquivo `.RData` estiver no diretório de trabalho ele será automaticamente carregado tornando todos os objetos da última sessão disponíveis novamente. 
Se você deseja salvar o espaço de trabalho em outro momento use a função `save.image()`.

Quando desejamos salvar só uma parte dos dados uma opção é usar a função `rm()` (uma abreviação de **remove**) para remover objetos que não são de interesse antes de finalizar a sessão do R. A função `save()`permite salvar *mais de um objeto* em um mesmo arquivo. 

```{r Chunk6112, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
save(cab, chuva_df, file = "data/dados_prec.RData")
ls()
rm(cab, chuva_df)
ls()
# carrega e imprime na tela nome dos dados carregados
print(load("data/dados_prec.RData"))
```

### `readRDS()` e `saveRDS()`

As funções `readRDS()` e `writeRDS()` são similares a `load()` e `save()`, respectivamente, exceto que elas lidam com **um único objeto**. Em contrapartida elas possuem a flexibilidade nomear o objeto lido com um nome diferente do qual ele foi salvo.
Vamos alterar o formato da data do *data frame* `chuva_df` e salvá-lo no arquivo `chuva_df.rds`.

```{r Chunk6120, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# salvar dados em um arquivo rds
head(chuva_df[, 1:10])
# alterando formato de datas da coluna Data
chuva_df$Data <- as.Date(x = chuva_df$Data, format = "%d/%m/%Y")
saveRDS(object = chuva_df, file = "data/chuva_df.rds")
file.exists("data/chuva_df.rds")
```

Após salvar o *data frame* `chuva_df` vamos removê-lo do ambiente da sessão e recuperá-lo com a função `readRDS()`.

```{r Chunk6121, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# removendo chuva_df do ambiente
rm(chuva_df)
# recuperando dados do arquivo em uma variável com nome diferente do original
prec_ana <- readRDS("data/chuva_df.rds")
head(prec_ana[, 1:10])
```

## Arquivos binários do [TRMM](http://pmm.nasa.gov/trmm)

*Download* do arquivo binário com estimativa da precipitação pelo satélite TRMM. O produto 3B42  possui resolução espacial de 0.25º, cobertura espacial global e temporal de 3 horas.

```{r Chunk6210, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=FALSE, eval=TRUE}
# CHUNCK OCULTO
ftp_trmm_file <- "ftp://disc2.nascom.nasa.gov/data/TRMM/Gridded/3B42_V7/201407/3B42.140701.09z.7.precipitation.bin"
if(file.exists(basename(ftp_trmm_file))){
  bin_data <- readBin(con = basename(ftp_trmm_file),
                    what = "numeric", 
                    endian = "big",
                    size = 4,
                    n = 1440*400)
}
```


```{r Chunk6211, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=FALSE}
# ftp com aruivos binários de estimativa de precipitação a cada 3 h do TRMM 3B42
ftp_trmm_file <- "ftp://disc2.nascom.nasa.gov/data/TRMM/Gridded/3B42_V7/201407/3B42.140701.09z.7.precipitation.bin"
# download do arquivo
download.file(ftp_trmm_file, destfile = file.path("data",basename(ftp_trmm_file)))
# leitura do link para o arquivo readme 
readme <- readLines("ftp://disc2.nascom.nasa.gov/data/TRMM/Gridded/3B42_V7/readme")
# escrevendo readme em arquivo texto 
writeLines(text = readme, con = "data/readme_TRMM.txt")
# abrindo arquivo para visualização
file.show("readme_TRMM.txt")
```

Leitura do arquivo binário.

```{r Chunk6212, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# importando arquivo binário  
bin_data <- readBin(con = file.path("data",basename(ftp_trmm_file)),
                    what = "numeric", 
                    endian = "big",
                    size = 4,
                    n = 1440*400)
```


```{r Chunk6213, message=FALSE, comment="",prompt=FALSE, echo=FALSE, eval=TRUE}
is.vector(bin_data)
# estruturando valores do arquivo como uma matriz
m <- matrix(bin_data, ncol = 1440, byrow = TRUE)
str(m)
```

Para visualizarmos os dados lidos, vamos usar a função `levelplot()` do pacote [lattice](http://cran.r-project.org/web/packages/lattice/index.html). Essa função permite rapidamente visualizar o campo espacial da precipitação. As cores que devem ser usados para colorir os níveis de variação da precipitação. Vamos remover os dados abaixo de 0.5 mm/h para destacar os sistemas precipitantes.

```{r Chunk6214, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# Visualização dos dados
# install.packages(lattice, dep = TRUE)
require(lattice)
# definindo paleta de cores para o gráfico
paleta <- rev(topo.colors(32)) # rev() inverte a ordem do vetor
levelplot(t(m),
          col.regions = rev(terrain.colors(32)), 
          xlab = "x", 
          ylab = "y")
# para melhor visualização vamos substituir valores abaixo de 0.1 mm/dia por NA
m[m < 0.5] <- NA
# gráfico com valores apenas onde choveu
levelplot(t(m), 
          col.regions = paleta,  
          xlab = "x", 
          ylab = "y")
```


## NetCDF (Network Common Data Form) 

NetCDF é formato binário, auto-descritivo e independente do SO, para criar e distribuir *arrays* multidimensionais de dados gradeados. Originalmente foi desenvolvido para o armazenamento e distribuição de dos climáticos, tais como os gerados por modelos climáticos e sistemas de assimilação de dados como as [reanálises](http://en.wikipedia.org/wiki/Meteorological_reanalysis).

As bibliotecas NetCDF são mantidas pelo [Unidata](http://www.unidata.ucar.edu/software/netcdf/). Dados no formato NetCDF são acessíveis no R pelos pacotes [ncdf](http://cran.r-project.org/web/packages/ncdf/index.html), [ncdf4](http://cran.r-project.org/web/packages/ncdf4/index.html) e [raster](http://cran.r-project.org/web/packages/raster/index.html). Esses pacotes fornecem o suporte necessário para leitura e escrita de arquivos NetCDF. O pacote `ncdf` é disponível para Linux e Mac OS X, mas suporta somente arquivo no formato NetCDF 3, enquanto o pacote `ncdf4` lê arquivos no formato NetCDF 3 e 4, porém é disponível apenas para sistemas Linux.

### Pré-requisitos

Para utilizar os pacotes `ncdf*` é necessário instalar o pacote linux `netcdf-bin`.

        apt-get install netcdf-bin

### Exemplo

Os exemplos a seguir usam o pacote [ncdf4](https://cran.r-project.org/web/packages/ncdf4/index.html) para ler arquivo NetCDF com dados climáticos do *Climate Research Unit [CRU](http://www.cru.uea.ac.uk/data)*, consistindo de valores médios de longo prazo (1961-1990) da  temperatura do ar próximo à superfície  com resolução espacial de 0,5 º na área continental. As dimensões da *array* são: 720 (longitudes) x 360 (latitudes) x 12 (meses).

Carregando pacotes necessários:

```{r Chunk630, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# Se não tiver o pacote instale-o, p.ex.: 
# install.packages("ncdf4", dep = TRUE)
# depois carregamos os pacotes
library(chron)
library(RColorBrewer)
library(lattice)
library(ncdf4)
library(fields)
```

Abrindo arquivo NetCDF e obtendo informações básicas.

```{r Chunk631, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# nome do arquivo netcdf
ncname <- "data/cru10min30_tmp"
ncfname <- paste(ncname, ".nc", sep = "")
# variável de interesse, tmp: temperatura do ar
dname <- "tmp"  
# abre o arquivo NetCDF
ncin <- nc_open(ncfname)
print(ncin)
# estrutura dos dados
str(ncin)
# classe
class(ncin)
# modo
mode(ncin)
```

Agora, vamos ler as coordenadas de longitude e latitude. 

```{r Chunk632, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
lon <- ncvar_get(ncin, "lon")
nlon <- dim(lon)
head(lon)
lat <- ncvar_get(ncin, "lat", verbose = F)
nlat <- dim(lat)
head(lat)
c(nlon, nlat)
```

Vamos obter a variável temporal e seus atributos usando as funções `ncvarget()` e `ncatt_get`. Depois fechamos o acesso ao arquivo NetCDF.

```{r Chunk633, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
t <- ncvar_get(ncin, "time")
(tunits <- ncatt_get(ncin, "time", "units"))
(nt <- dim(t))
tmp.array <- ncvar_get(ncin, dname)
# resumo da estrutura dos dados
str(tmp.array)
# nome longo da variável
(dlname <- ncatt_get(ncin, dname, "long_name"))
# unidades da variável
(dunits <- ncatt_get(ncin, dname, "units"))
# valor definido para valores faltantes
(fillvalue <- ncatt_get(ncin, dname, "_FillValue"))
# fechando arquivo
nc_close(ncin)
```

As variáveis do arquivo NetCDF são lidas e escritas como vetores (p.ex.: longitudes), *arrays* bidimensionais (matrizes, campo espacial de um momento), ou *arrays* multidimensionais (campos espaciais de uma variável em diversos tempos).

Vamos extrair o campo espacial de um passo de tempo (1 dia), criar um data frame onde cada linha será um ponto de grade e a coluna representa uma variável, por exemplo: longitude, latitude e temperatura. Finalmente vamos exportar o data frame para um arquivo `csv`.

```{r Chunk634, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
m <- 1
# campo espacial do primeiro dia de dados
tmp.slice <- tmp.array[, , m]
str(tmp.slice)
# outra função para visualizar dados com 3D
image.plot(lon, lat, tmp.slice, col = rev(brewer.pal(10, "RdBu")))
```


# Dados de outros softwares

Há funções no R que permitem importar dados diretamente de diversos softwares, inclusive de planilhas eletrônicas. O pacote `foreign` (estrangeiro em português) oferece diversas funções para importação dados de outros programas. Para verificar as funções disponíveis confira os comandos abaixo.

```{r Chunk700, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# install.packages("foreign")
require(foreign)
library(help = foreign)
ls(name = "package:foreign", pattern = "^[rea|wri]")
```

A função `read.dbf()` lê arquivos no formato típico de softwares de manipulação de banco de dados, como por exemplo o Microsoft Access.

O pacote `R.matlab` fornece a função `read.matlab()` para leitura de dados no formato [Matlab](http://www.mathworks.com/products/matlab/).

## Excel 

O armazenamento de dados em formato Excel (arquivos com extensões `.xls` e `.xlsx`) é uma prática muito popular. Mas infelizmente ler dados Excel não é tão simples, especialmente fora do ambiente Windows, apesar da variedade de pacotes disponíveis para tal tarefa. 
Há uma razoável variedade de pacotes para resolver esse problema: **gdata, XLConnect, xlsReadWrite** e outros, mas todos tem alguma dependência, tal como, Java, Perl ou R 32 bit, que são geralmente inviáveis.

Assim é bem provável que você terá que testar diferentes pacotes e as suas dependências para encontrar uma ferramenta que adeque a sua escolha de SO e tipo de arquivo Excel.

A solução mais simples é converter as planilhas Excel para `csv` usando algum programa.

Aqui vamos mostrar como usar o pacote [XLConnect](https://cran.r-project.org/web/packages/XLConnect/index.html) para leitura de arquivos Excel, em ambos formatos `xls` e `xlsx`; com uma ou mais planilhas. A leitura pode ser feita em dois passos: 1) carregar o arquivo Excel, com a função `loadworkbook()`; 2) ler a(s) planilha(s) do arquivo carregado.


```{r Chunk710, message=FALSE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE, warning=FALSE}
# sessionInfo()
library(XLConnect)
# nome do arquivo excel
xls_file <- "data/06_Junho-00.xls"
# carregando planilhas do arquivo
wb <- loadWorkbook(xls_file)
# obtendo nome das planilhas do arquivo
nomes_planilhas <- getSheets(wb)
nomes_planilhas
# lendo dados da planilha 1
dados_planilha1 <- readWorksheet(wb, sheet = nomes_planilhas[1])
str(dados_planilha1)
# lista com dados de todas planilhas do arquivo excel
lst <- readWorksheet(wb, sheet = nomes_planilhas)
str(lst)
# dados da planilha 1
lst[[1]]
```

Os dados lidos são armazenados em um *data frame*, quando especificado apenas uma planilha, ou uma lista, quando mais de uma planilha é especificada. É possível informar os intervalos de linhas e colunas de interesse usando argumentos adicionais da função `readWorksheet()`. `r names(formals(readWorksheet))`

Para escrever um arquivo `xls` use a função `writeWorksheet()`.

## Bancos de dados relacionais 

Quando dados precisam ser acessados por muitas pessoas, a melhor opção é armazená-los em [Banco de Dados Relacional, BDR](http://pt.wikipedia.org/wiki/Banco_de_dados_relacional). Existem diversos Sistemas Gerenciadores de Banco de Dados Relacional (SGBDR) (do inglês *Relational database management system*, RDBMS) que operam BDRs. O R pode conectar-se a diversos SGBDR e ler os dados de um [BDR](http://pt.wikipedia.org/wiki/Banco_de_dados_relacional).

O [pacote DBI (Database Interface)](http://cran.r-project.org/web/packages/DBI/README.html) fornece uma sintaxe unificada para acessar diversos SGBDR, como: [SQLite](http://www.sqlite.org/about.html), [MySQL](https://www.mysql.com/), [PostgreSQL](http://www.postgresql.org/) e [Oracle](http://pt.wikipedia.org/wiki/Oracle_%28banco_de_dados%29) entre outros. Dependendo do tipo de banco de dados é necessário baixar o pacote específico para ser usado com o pacote `DBI`. Esses pacotes formam a interface com os SGBDR. Para o MySQL há o pacote [RMySQL](http://cran.r-project.org/web/packages/RMySQL/index.html), para o SQLite há o pacote [RSQLite](http://cran.r-project.org/web/packages/RSQLite/index.html), e assim por diante. 

Após carregar o pacote apropriado podemos usar as funções do `DBI` para acessar o banco de dados. Para mostrar como ler um BDR, usaremos um banco de dados [SQLite](http://pt.wikipedia.org/wiki/SQLite) gentilmente cedido pelo [GRUMA-UFSM](https://www.facebook.com/GrupoDeModelagemAtmosfericaDeSantaMariaUfsm). O BDR contém informações sobre o rastreamento de Sistemas Convectivos de Mesoescala (SCMs) na região Sul do Brasil para o ano de 2005.

Para conexão com o banco de dados [SQLite](http://pt.wikipedia.org/wiki/SQLite), primeiro precisamos instalar e carregar o pacote `DBI` e o pacote `RSQLite`.

```{r Chunk720, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
#install.packages("DBI", dep = TRUE)
library(DBI)
#install.packages("RSQLite", dep = TRUE)
library(RSQLite)
```

A seguir, definimos o *driver* do banco de dados como SQLite e configuramos a conexão ao banco de dados, nesse caso definindo uma variável com o nome do arquivo (`db_file`). 

```{r Chunk721, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# nome do SGBDR
driver <- dbDriver("SQLite")
# nome do arquivo com banco de dados
db_file <- "data/rastreador1.db3"
# conectando com o BDR
conn <- dbConnect(driver, db_file)
conn
```

A função `dbListTables()` extrai o nome das tabelas contidas no banco de dados conectado através do objeto `conn`. 

```{r Chunk722, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
tab_list <- dbListTables(conn)
tab_list
```

Com a função `dbReadTable()` podemos ler uma tabela do banco de dados.

```{r Chunk723, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# lendo tabela imagem_nuvem
imagem_nuvem <- dbReadTable(conn, "imagem_nuvem")
head(imagem_nuvem)
tail(imagem_nuvem)
```

Para ler cada uma das tabela do banco e salvá-la com o mesmo nome usado no banco de dados podemos fazer um *looping* com a função `for()` e usar a função `assign()` para atribuir nomes as tabelas.

```{r Chunk724, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# lendo cada tabela do banco e criando um data frame 
# com mesmo nome da tabela dentro do banco de dados
for(i in tab_list) assign(i, dbReadTable(conn, i))
# verificando se as tabelas foram criadas
all(tab_list %in% ls())
```

Após a leitura das tabelas de interesse podemos desconectar o banco de dados e o *driver*.

```{r Chunk725, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# desconectando do banco
dbDisconnect(conn)
dbUnloadDriver(driver)
```

O trabalho com banco de dados exige experiência que vai além das habilidades de um típico usuário de R. Para os interessados nisso, um bom lugar para começar é baixar os pacotes citados e ler a documentação deles.

## Arquivos [Shapefiles do ArcGis](http://doc.arcgis.com/pt-br/arcgis-online/reference/shapefiles.htm)

```{r Chunk730, message=FALSE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
#install.packages("raster", dep = TRUE)
library(raster)
bacias <- shapefile("data/Ottobacias_Nivel2.shp")
class(bacias)
str(bacias)
plot(bacias)
```


  
# Arquivos e diretórios

## Diretório de trabalho

O R possui uma variedade de funções para se obter informações sobre arquivos, diretórios, permissões de acesso e etc.

Quando abrimos uma sessão no R, ela é associada a um diretório de trabalho (*working directory*, `wd`). Esse local é a primeiro diretório onde o R irá salvar ou ler um arquivo de dados, se o caminho completo até o arquivo não for especificado. Para saber qual é o diretório de trabalho usamos a função `getwd()`. Para alterar o `wd` usamos `setwd()`. Para listar o conteúdo de um diretório usamos a função `dir()`.

```{r Chunk810, message=TRUE, comment="",prompt=FALSE, tidy=FALSE, echo=TRUE, eval=TRUE}
# variável do tipo character com nome do diretório
(wd <- getwd())
class(wd)
# altere o caminho para "/home/lci"
setwd("/home/hidrometeorologista/")
getwd()
# volta para o wd
setwd(wd)
getwd()
```

Para saber o diretório de instalação do R, usamos `R.home()`. O local de instalação dos pacotes é obtido via `.libPaths()`.

## Caminhos de arquivos e informações básicas

Podemos construir o caminho até um arquivo usando o nome do diretório e do arquivo com a função `file.path()`. O que é equivalente a função `paste(a, b, sep = "/")`. A partir da `string` com o caminho completo para o arquivo, podemos extrair o diretório (`dirname()`), o nome do arquivo () e a extensão do arquivo.

```{r Chunk820, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
# carregando pacote tools para usar função file_ext()
library(tools)
# emenda diretorio ao nome do aruivo com "/"
file_name <- file.path(wd, "CHUVAS.TXT")
file.path("/home", "lci", "nome_aluno", "R")
# equivalente a
paste(file.path(wd, "CHUVAS.TXT"), sep = "/")
# diretório de um arquivo
dirname(file_name)
# nome do arquivo
basename(file_name)
# extensão do arquivo
file_ext(file_name)
```

A função `file.exists()` permite verificar se um arquivo já existe, o que pode ser usado para evitar de sobrescrever um arquivo com mesmo nome. Metadados do arquivo podem ser obtidos via `file.info()`.

```{r Chunk821, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=FALSE}
# seleção iterativa de um arquivo
arq_name <- file.choose()
arq_name
```

```{r Chunk822, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
# verifica existência do arquivo
file.exists(file_name)
# tamanho, data de criação, permissões, etc 
file.info("data/chuva_df.RData")
```

## Conteúdo de diretórios

Para listar o conteúdo de um diretório usamos as funções `dir()` e `list.dirs()`.
A função `list.files()` permite listar arquivos usando [regex](http://pt.wikipedia.org/wiki/Express%C3%A3o_regular). Uma boa referência para aprender [regex](http://pt.wikipedia.org/wiki/Express%C3%A3o_regular) é o site do [Aurélio](http://aurelio.net/regex/guia/). Nós vamos ver aqui apenas algumas regex básicas para ilustrar o uso da `list.files()`.

```{r Chunk830, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
# lista conteúdo do diretórios
dir()
# lista diretórios  e sub-dirs
list.dirs()
# lista diretórios, sem sub-dirs
list.dirs(recursive = FALSE)
# lista diretórios incluindo caminho relativo
list.dirs(full.names = TRUE)
# lista todos arquivo que terminam com txt
# "txt$" é uma expressão regular (regex)
list.files(pattern = "txt$")
list.files(pattern = "txt$|TXT$")
# arquivos que iniciam com m ou S
list.files(path = ".",pattern = "^[m, S]")
```


## Manipulação de arquivos e diretórios

Para ilustrar as funções de manipulação de arquivos e diretórios vamos realizar os seguintes procedimentos:

+ Criar um diretório para armazenar dados utilizados no curso até agora;

```{r Chunk850, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
(new_dir <- file.path("/home", Sys.getenv()[["LOGNAME"]], "dados_adar"))
if(!dir.exists(new_dir)) dir.create(new_dir)
dir.exists(new_dir)
```

+ selecionar os arquivos de dados do curso no diretório de trabalho

```{r Chunk851, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
# lista dos 30 primeiros arquivos no wd
head(all_files <- list.files(recursive = TRUE), 30)
# extensões dos arquivos de dados usados no curso
extensoes <- c("txt", "TXT", "nc","xls", "bin", "csv", "RData", "rds", "zip", "asc", "dbf", "prj", "sbn", "sbx", "shp", "shx", "db3")
# arquivos de dados do curso selecionados
(sel_files <- all_files[file_ext(all_files) %in% extensoes])
```

+ copiar esses arquivos para o novo diretório;

```{r Chunk852, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
file.copy(from = sel_files, 
          to = new_dir,
          overwrite = TRUE)
```

+ remover alguns arquivos do novo diretório;

```{r Chunk853, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
# arquivos que começam como "O" ou "S"
files2remove <- list.files(path = new_dir, 
                           pattern = "^[O, S]",
                           full.names = TRUE)
files2remove
file.remove(files2remove)
list.files(path = new_dir, 
           pattern = "^[O, S]", 
           full.names = TRUE)
```

Veja mais funções para manipulação de arquivos em `?connections`.

Para criar arquivos e diretórios temporários podemos usar as funções `tempfile()` e `tempdir()`, respectivamente. O exemplo abaixo mostra como baixar o arquivo da internet em um arquivo temporário.

```{r Chunk854, message=TRUE, comment="",prompt=FALSE, echo=TRUE, eval=TRUE}
tempdir()
tempfile()
# baixando dados da web
arq_temp <- tempfile()
download.file(url = "http://www.cpc.ncep.noaa.gov/data/indices/soi",
              destfile = arq_temp)
# lendo arquivo baixado
(soi <- readLines(arq_temp, n = 10))
# apagando o arquivo tmp
file.remove(arq_temp)
```

